<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://cdn.tailwindcss.com"></script>
  </head>

  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@undecaf/zbar-wasm@latest/dist/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback } = React;

      // 커스텀 훅: 카메라 관리
      const useCamera = () => {
        const videoRef = useRef(null);
        const [cameraError, setCameraError] = useState(null);
        const [isAccessingCamera, setIsAccessingCamera] = useState(false);

        const startCamera = useCallback(async () => {
          setIsAccessingCamera(true);
          setCameraError(null);

          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "environment" },
            });

            if (videoRef.current) {
              videoRef.current.srcObject = stream;
            }
          } catch (error) {
            console.error("카메라 접근 오류:", error);
            setCameraError("카메라에 접근할 수 없습니다.");
          } finally {
            setIsAccessingCamera(false);
          }
        }, []);

        const stopCamera = useCallback(() => {
          if (videoRef.current?.srcObject) {
            const tracks = videoRef.current.srcObject.getTracks();
            tracks.forEach((track) => track.stop());
            videoRef.current.srcObject = null;
          }
        }, []);

        return {
          videoRef,
          startCamera,
          stopCamera,
          cameraError,
          isAccessingCamera,
        };
      };

      // 커스텀 훅: QR 스캐너
      const useQRScanner = () => {
        const canvasRef = useRef(null);
        const [isScanning, setIsScanning] = useState(false);
        const scanIntervalRef = useRef(null);

        const startScanning = useCallback((videoElement, onQRDetected) => {
          if (!videoElement || !canvasRef.current) return;

          setIsScanning(true);
          const canvas = canvasRef.current;
          const context = canvas.getContext("2d", { willReadFrequently: true });

          const updateCanvasSize = () => {
            if (videoElement.videoWidth && videoElement.videoHeight) {
              canvas.width = videoElement.videoWidth;
              canvas.height = videoElement.videoHeight;
            }
          };

          videoElement.addEventListener("loadedmetadata", updateCanvasSize);
          updateCanvasSize();

          scanIntervalRef.current = setInterval(async () => {
            try {
              context.drawImage(
                videoElement,
                0,
                0,
                canvas.width,
                canvas.height,
              );
              const imageData = context.getImageData(
                0,
                0,
                canvas.width,
                canvas.height,
              );
              const symbols = await window.zbarWasm.scanImageData(imageData);

              if (symbols.length > 0) {
                const decodedData = symbols[0].decode();
                onQRDetected(decodedData);
              }
            } catch (error) {
              console.error("QR 스캔 오류:", error);
            }
          }, 50); // 50ms로 변경하여 생성기와 동기화
        }, []);

        const stopScanning = useCallback(() => {
          setIsScanning(false);
          if (scanIntervalRef.current) {
            clearInterval(scanIntervalRef.current);
            scanIntervalRef.current = null;
          }
        }, []);

        return { canvasRef, isScanning, startScanning, stopScanning };
      };

      // 메인 컴포넌트
      const QRDataReceiver = () => {
        // 상태 관리
        const [userMessage, setUserMessage] = useState(
          "'Start Receiver' 버튼을 클릭하세요",
        );
        const [decodedChunks, setDecodedChunks] = useState({});
        const [fileMetadata, setFileMetadata] = useState({});
        const [receivedText, setReceivedText] = useState("");
        const [showResult, setShowResult] = useState(false);
        const [isReceiving, setIsReceiving] = useState(false);

        // 커스텀 훅 사용
        const { videoRef, startCamera, stopCamera, cameraError } = useCamera();
        const { canvasRef, startScanning, stopScanning } = useQRScanner();

        // 유틸리티 함수들
        const decodeData = useCallback((inputString) => {
          const parts = inputString.split(",");
          const index = parseInt(parts[0], 10);
          const base64Data = parts[1];
          const binaryString = atob(base64Data);
          const data = Array.from(binaryString, (char) => char.charCodeAt(0));
          return { index, data };
        }, []);

        const downloadFile = useCallback((data, fileName) => {
          const blob = new Blob([data]);
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = fileName;
          link.click();
          URL.revokeObjectURL(link.href);
        }, []);

        const copyText = useCallback(async () => {
          try {
            await navigator.clipboard.writeText(receivedText);
            setUserMessage("클립보드에 복사되었습니다!");
            setTimeout(() => setUserMessage("수신 완료"), 2000);
          } catch (error) {
            console.error("복사 실패:", error);
            setUserMessage("복사에 실패했습니다.");
          }
        }, [receivedText]);

        const shareText = useCallback(async () => {
          try {
            if (navigator.share) {
              await navigator.share({
                title: `QR 데이터: ${fileMetadata.name}`,
                text: receivedText,
              });
              setUserMessage("텍스트 공유 완료!");
            } else {
              await navigator.clipboard.writeText(receivedText);
              setUserMessage("Web Share 미지원. 클립보드에 복사되었습니다!");
            }
            setTimeout(() => setUserMessage("수신 완료"), 2000);
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error("텍스트 공유 실패:", error);
              setUserMessage("텍스트 공유에 실패했습니다.");
            }
          }
        }, [receivedText, fileMetadata.name]);

        const shareAsFile = useCallback(async () => {
          try {
            const blob = new Blob([receivedText], {
              type: "text/plain;charset=utf-8",
            });
            const fileName = fileMetadata.name || "qr-data.txt";
            const file = new File([blob], fileName, { type: "text/plain" });

            if (
              navigator.share &&
              navigator.canShare &&
              navigator.canShare({ files: [file] })
            ) {
              await navigator.share({
                title: `QR 데이터: ${fileName}`,
                files: [file],
              });
              setUserMessage("파일 공유 완료!");
            } else {
              // 파일 공유 미지원시 다운로드로 폴백
              downloadAsFile();
              setUserMessage("파일 공유 미지원. 파일을 다운로드했습니다.");
            }
            setTimeout(() => setUserMessage("수신 완료"), 2000);
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error("파일 공유 실패:", error);
              setUserMessage("파일 공유에 실패했습니다.");
            }
          }
        }, [receivedText, fileMetadata.name, downloadAsFile]);

        const downloadAsFile = useCallback(() => {
          try {
            const blob = new Blob([receivedText], {
              type: "text/plain;charset=utf-8",
            });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = fileMetadata.name || "qr-data.txt";
            link.click();
            URL.revokeObjectURL(link.href);
            setUserMessage("파일 다운로드 완료!");
            setTimeout(() => setUserMessage("수신 완료"), 2000);
          } catch (error) {
            console.error("다운로드 실패:", error);
            setUserMessage("다운로드에 실패했습니다.");
          }
        }, [receivedText, fileMetadata.name]);

        // QR 코드 처리
        const handleQRDetected = useCallback(
          (decodedData) => {
            if (decodedData.includes('"chunks"')) {
              try {
                const metadata = JSON.parse(decodedData);
                setFileMetadata(metadata);
                setDecodedChunks({});
                setUserMessage(`파일 수신 중: ${metadata.name}`);
              } catch (error) {
                console.error("메타데이터 파싱 오류:", error);
              }
            } else if (decodedData.includes(",")) {
              try {
                const rawData = decodeData(decodedData);
                setDecodedChunks((prev) => ({
                  ...prev,
                  [rawData.index]: rawData.data,
                }));
              } catch (error) {
                console.error("데이터 청크 디코딩 오류:", error);
              }
            }
          },
          [decodeData],
        );

        // 수신 시작
        const startReceiver = useCallback(async () => {
          setDecodedChunks({});
          setShowResult(false);
          setReceivedText("");
          setIsReceiving(true);
          setUserMessage("QR 코드를 스캔하고 있습니다...");

          await startCamera();

          setTimeout(() => {
            if (videoRef.current) {
              startScanning(videoRef.current, handleQRDetected);
            }
          }, 1000);
        }, [startCamera, startScanning, handleQRDetected]);

        // 수신 중지
        const stopReceiver = useCallback(() => {
          setIsReceiving(false);
          stopScanning();
          stopCamera();
          setDecodedChunks({});
          setFileMetadata({});
          setShowResult(false);
          setReceivedText("");
          setUserMessage(
            "수신이 중지되었습니다. 다시 시작하려면 버튼을 클릭하세요.",
          );
        }, [stopScanning, stopCamera]);

        // 데이터 수신 완료 처리
        useEffect(() => {
          if (!isReceiving || !fileMetadata.chunks) return;

          const receivedChunkCount = Object.keys(decodedChunks).length;
          if (receivedChunkCount === fileMetadata.chunks) {
            setUserMessage("수신된 데이터를 처리하고 있습니다...");

            const outputArray = [];
            for (let i = 0; i < fileMetadata.chunks; i++) {
              if (decodedChunks[i]) {
                outputArray.push(...decodedChunks[i]);
              }
            }

            try {
              const compressedArray = new Uint8Array(outputArray);
              const inflatedArray = window.pako.ungzip(compressedArray);

              const fileName = fileMetadata.name.toLowerCase();
              const isTextFile = [
                ".txt",
                ".js",
                ".py",
                ".html",
                ".css",
                ".json",
                ".md",
                ".csv",
                ".xml",
                ".yaml",
                ".svg",
              ].some((ext) => fileName.endsWith(ext));

              if (isTextFile) {
                const text = new TextDecoder().decode(inflatedArray);
                setReceivedText(text);
                setShowResult(true);
                setUserMessage("텍스트가 성공적으로 수신되었습니다!");
              } else {
                downloadFile(inflatedArray, fileMetadata.name);
                setUserMessage(
                  `파일 '${fileMetadata.name}'이 다운로드되었습니다!`,
                );
              }
            } catch (error) {
              console.error("데이터 처리 오류:", error);
              setUserMessage("데이터 처리 중 오류가 발생했습니다.");
            }

            stopScanning();
            setIsReceiving(false);
          }
        }, [
          decodedChunks,
          fileMetadata,
          isReceiving,
          stopScanning,
          downloadFile,
        ]);

        const progress = fileMetadata.chunks
          ? Object.keys(decodedChunks).length
          : 0;
        const totalChunks = fileMetadata.chunks || 0;

        return (
          <div className="w-full max-w-2xl mx-auto p-4">
            <div className="flex flex-col items-center justify-center w-full">
              <div className="text-xl my-4 font-bold">Data Receiver Mode</div>
              <div className="text-sm mb-4 h-5">{userMessage}</div>
              <div className="text-sm mb-4">
                Progress: {progress} / {totalChunks}
              </div>

              {/* 카메라 에러 표시 */}
              {cameraError && (
                <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
                  {cameraError}
                </div>
              )}

              {/* 수신 버튼 */}
              {!isReceiving ? (
                <button
                  onClick={startReceiver}
                  className="mb-6 px-4 py-2 border-2 border-gray-500 rounded-md hover:bg-gray-100"
                >
                  Start Receiver
                </button>
              ) : (
                <button
                  onClick={stopReceiver}
                  className="mb-6 px-4 py-2 border-2 border-red-500 text-red-500 rounded-md hover:bg-red-50"
                >
                  Stop Receiver
                </button>
              )}

              {/* 비디오 스트림 */}
              <video
                ref={videoRef}
                muted
                autoPlay
                playsInline
                className="w-full border bg-gray-200 rounded-lg"
              />

              {/* 숨겨진 캔버스 */}
              <canvas ref={canvasRef} style={{ display: "none" }} />

              {/* 결과 표시 */}
              {showResult && (
                <div className="w-full mt-6">
                  <div className="flex flex-col gap-2 mb-4">
                    <h3 className="text-lg font-semibold">
                      Received Text ({fileMetadata.name})
                    </h3>
                    <div className="flex gap-2 flex-wrap">
                      <button
                        onClick={copyText}
                        className="px-3 py-2 border-2 border-blue-500 text-blue-500 rounded-md hover:bg-blue-50 flex items-center gap-1"
                      >
                        📋 Copy
                      </button>
                      <button
                        onClick={shareText}
                        className="px-3 py-2 border-2 border-green-500 text-green-500 rounded-md hover:bg-green-50 flex items-center gap-1"
                      >
                        📤 텍스트 공유
                      </button>
                      <button
                        onClick={shareAsFile}
                        className="px-3 py-2 border-2 border-orange-500 text-orange-500 rounded-md hover:bg-orange-50 flex items-center gap-1"
                      >
                        📎 파일 공유
                      </button>
                      <button
                        onClick={downloadAsFile}
                        className="px-3 py-2 border-2 border-purple-500 text-purple-500 rounded-md hover:bg-purple-50 flex items-center gap-1"
                      >
                        💾 Download
                      </button>
                    </div>
                  </div>
                  <textarea
                    readOnly
                    value={receivedText}
                    className="w-full h-72 p-2 border border-gray-300 rounded-md bg-gray-50 font-mono text-sm"
                  />
                </div>
              )}
            </div>
          </div>
        );
      };

      // 앱 렌더링
      ReactDOM.render(<QRDataReceiver />, document.getElementById("root"));
    </script>
  </body>
</html>
