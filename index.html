<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://cdn.tailwindcss.com"></script>
  </head>

  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@undecaf/zbar-wasm@latest/dist/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback } = React;

      // ì»¤ìŠ¤í…€ í›…: ì¹´ë©”ë¼ ê´€ë¦¬
      const useCamera = () => {
        const videoRef = useRef(null);
        const [cameraError, setCameraError] = useState(null);
        const [isAccessingCamera, setIsAccessingCamera] = useState(false);

        const startCamera = useCallback(async () => {
          setIsAccessingCamera(true);
          setCameraError(null);

          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "environment" },
            });

            if (videoRef.current) {
              videoRef.current.srcObject = stream;
            }
          } catch (error) {
            console.error("ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜:", error);
            setCameraError("ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
          } finally {
            setIsAccessingCamera(false);
          }
        }, []);

        const stopCamera = useCallback(() => {
          if (videoRef.current?.srcObject) {
            const tracks = videoRef.current.srcObject.getTracks();
            tracks.forEach((track) => track.stop());
            videoRef.current.srcObject = null;
          }
        }, []);

        return {
          videoRef,
          startCamera,
          stopCamera,
          cameraError,
          isAccessingCamera,
        };
      };

      // ì»¤ìŠ¤í…€ í›…: QR ìŠ¤ìºë„ˆ
      const useQRScanner = () => {
        const canvasRef = useRef(null);
        const [isScanning, setIsScanning] = useState(false);
        const scanIntervalRef = useRef(null);

        const startScanning = useCallback((videoElement, onQRDetected) => {
          if (!videoElement || !canvasRef.current) return;

          setIsScanning(true);
          const canvas = canvasRef.current;
          const context = canvas.getContext("2d", { willReadFrequently: true });

          const updateCanvasSize = () => {
            if (videoElement.videoWidth && videoElement.videoHeight) {
              canvas.width = videoElement.videoWidth;
              canvas.height = videoElement.videoHeight;
            }
          };

          videoElement.addEventListener("loadedmetadata", updateCanvasSize);
          updateCanvasSize();

          scanIntervalRef.current = setInterval(async () => {
            try {
              context.drawImage(
                videoElement,
                0,
                0,
                canvas.width,
                canvas.height,
              );
              const imageData = context.getImageData(
                0,
                0,
                canvas.width,
                canvas.height,
              );
              const symbols = await window.zbarWasm.scanImageData(imageData);

              if (symbols.length > 0) {
                const decodedData = symbols[0].decode();
                onQRDetected(decodedData);
              }
            } catch (error) {
              console.error("QR ìŠ¤ìº” ì˜¤ë¥˜:", error);
            }
          }, 50); // 50msë¡œ ë³€ê²½í•˜ì—¬ ìƒì„±ê¸°ì™€ ë™ê¸°í™”
        }, []);

        const stopScanning = useCallback(() => {
          setIsScanning(false);
          if (scanIntervalRef.current) {
            clearInterval(scanIntervalRef.current);
            scanIntervalRef.current = null;
          }
        }, []);

        return { canvasRef, isScanning, startScanning, stopScanning };
      };

      // ë©”ì¸ ì»´í¬ë„ŒíŠ¸
      const QRDataReceiver = () => {
        // ìƒíƒœ ê´€ë¦¬
        const [userMessage, setUserMessage] = useState(
          "'Start Receiver' ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”",
        );
        const [decodedChunks, setDecodedChunks] = useState({});
        const [fileMetadata, setFileMetadata] = useState({});
        const [receivedText, setReceivedText] = useState("");
        const [showResult, setShowResult] = useState(false);
        const [isReceiving, setIsReceiving] = useState(false);

        // ì»¤ìŠ¤í…€ í›… ì‚¬ìš©
        const { videoRef, startCamera, stopCamera, cameraError } = useCamera();
        const { canvasRef, startScanning, stopScanning } = useQRScanner();

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        const decodeData = useCallback((inputString) => {
          const parts = inputString.split(",");
          const index = parseInt(parts[0], 10);
          const base64Data = parts[1];
          const binaryString = atob(base64Data);
          const data = Array.from(binaryString, (char) => char.charCodeAt(0));
          return { index, data };
        }, []);

        const downloadFile = useCallback((data, fileName) => {
          const blob = new Blob([data]);
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = fileName;
          link.click();
          URL.revokeObjectURL(link.href);
        }, []);

        const copyText = useCallback(async () => {
          try {
            await navigator.clipboard.writeText(receivedText);
            setUserMessage("í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!");
            setTimeout(() => setUserMessage("ìˆ˜ì‹  ì™„ë£Œ"), 2000);
          } catch (error) {
            console.error("ë³µì‚¬ ì‹¤íŒ¨:", error);
            setUserMessage("ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
          }
        }, [receivedText]);

        const shareText = useCallback(async () => {
          try {
            if (navigator.share) {
              await navigator.share({
                title: `QR ë°ì´í„°: ${fileMetadata.name}`,
                text: receivedText,
              });
              setUserMessage("í…ìŠ¤íŠ¸ ê³µìœ  ì™„ë£Œ!");
            } else {
              await navigator.clipboard.writeText(receivedText);
              setUserMessage("Web Share ë¯¸ì§€ì›. í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!");
            }
            setTimeout(() => setUserMessage("ìˆ˜ì‹  ì™„ë£Œ"), 2000);
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error("í…ìŠ¤íŠ¸ ê³µìœ  ì‹¤íŒ¨:", error);
              setUserMessage("í…ìŠ¤íŠ¸ ê³µìœ ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
            }
          }
        }, [receivedText, fileMetadata.name]);

        const shareAsFile = useCallback(async () => {
          try {
            const blob = new Blob([receivedText], {
              type: "text/plain;charset=utf-8",
            });
            const fileName = fileMetadata.name || "qr-data.txt";
            const file = new File([blob], fileName, { type: "text/plain" });

            if (
              navigator.share &&
              navigator.canShare &&
              navigator.canShare({ files: [file] })
            ) {
              await navigator.share({
                title: `QR ë°ì´í„°: ${fileName}`,
                files: [file],
              });
              setUserMessage("íŒŒì¼ ê³µìœ  ì™„ë£Œ!");
            } else {
              // íŒŒì¼ ê³µìœ  ë¯¸ì§€ì›ì‹œ ë‹¤ìš´ë¡œë“œë¡œ í´ë°±
              downloadAsFile();
              setUserMessage("íŒŒì¼ ê³µìœ  ë¯¸ì§€ì›. íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí–ˆìŠµë‹ˆë‹¤.");
            }
            setTimeout(() => setUserMessage("ìˆ˜ì‹  ì™„ë£Œ"), 2000);
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error("íŒŒì¼ ê³µìœ  ì‹¤íŒ¨:", error);
              setUserMessage("íŒŒì¼ ê³µìœ ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
            }
          }
        }, [receivedText, fileMetadata.name, downloadAsFile]);

        const downloadAsFile = useCallback(() => {
          try {
            const blob = new Blob([receivedText], {
              type: "text/plain;charset=utf-8",
            });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = fileMetadata.name || "qr-data.txt";
            link.click();
            URL.revokeObjectURL(link.href);
            setUserMessage("íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!");
            setTimeout(() => setUserMessage("ìˆ˜ì‹  ì™„ë£Œ"), 2000);
          } catch (error) {
            console.error("ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:", error);
            setUserMessage("ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
          }
        }, [receivedText, fileMetadata.name]);

        // QR ì½”ë“œ ì²˜ë¦¬
        const handleQRDetected = useCallback(
          (decodedData) => {
            if (decodedData.includes('"chunks"')) {
              try {
                const metadata = JSON.parse(decodedData);
                setFileMetadata(metadata);
                setDecodedChunks({});
                setUserMessage(`íŒŒì¼ ìˆ˜ì‹  ì¤‘: ${metadata.name}`);
              } catch (error) {
                console.error("ë©”íƒ€ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:", error);
              }
            } else if (decodedData.includes(",")) {
              try {
                const rawData = decodeData(decodedData);
                setDecodedChunks((prev) => ({
                  ...prev,
                  [rawData.index]: rawData.data,
                }));
              } catch (error) {
                console.error("ë°ì´í„° ì²­í¬ ë””ì½”ë”© ì˜¤ë¥˜:", error);
              }
            }
          },
          [decodeData],
        );

        // ìˆ˜ì‹  ì‹œì‘
        const startReceiver = useCallback(async () => {
          setDecodedChunks({});
          setShowResult(false);
          setReceivedText("");
          setIsReceiving(true);
          setUserMessage("QR ì½”ë“œë¥¼ ìŠ¤ìº”í•˜ê³  ìˆìŠµë‹ˆë‹¤...");

          await startCamera();

          setTimeout(() => {
            if (videoRef.current) {
              startScanning(videoRef.current, handleQRDetected);
            }
          }, 1000);
        }, [startCamera, startScanning, handleQRDetected]);

        // ìˆ˜ì‹  ì¤‘ì§€
        const stopReceiver = useCallback(() => {
          setIsReceiving(false);
          stopScanning();
          stopCamera();
          setDecodedChunks({});
          setFileMetadata({});
          setShowResult(false);
          setReceivedText("");
          setUserMessage(
            "ìˆ˜ì‹ ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.",
          );
        }, [stopScanning, stopCamera]);

        // ë°ì´í„° ìˆ˜ì‹  ì™„ë£Œ ì²˜ë¦¬
        useEffect(() => {
          if (!isReceiving || !fileMetadata.chunks) return;

          const receivedChunkCount = Object.keys(decodedChunks).length;
          if (receivedChunkCount === fileMetadata.chunks) {
            setUserMessage("ìˆ˜ì‹ ëœ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤...");

            const outputArray = [];
            for (let i = 0; i < fileMetadata.chunks; i++) {
              if (decodedChunks[i]) {
                outputArray.push(...decodedChunks[i]);
              }
            }

            try {
              const compressedArray = new Uint8Array(outputArray);
              const inflatedArray = window.pako.ungzip(compressedArray);

              const fileName = fileMetadata.name.toLowerCase();
              const isTextFile = [
                ".txt",
                ".js",
                ".py",
                ".html",
                ".css",
                ".json",
                ".md",
                ".csv",
                ".xml",
                ".yaml",
                ".svg",
              ].some((ext) => fileName.endsWith(ext));

              if (isTextFile) {
                const text = new TextDecoder().decode(inflatedArray);
                setReceivedText(text);
                setShowResult(true);
                setUserMessage("í…ìŠ¤íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì‹ ë˜ì—ˆìŠµë‹ˆë‹¤!");
              } else {
                downloadFile(inflatedArray, fileMetadata.name);
                setUserMessage(
                  `íŒŒì¼ '${fileMetadata.name}'ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!`,
                );
              }
            } catch (error) {
              console.error("ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜:", error);
              setUserMessage("ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
            }

            stopScanning();
            setIsReceiving(false);
          }
        }, [
          decodedChunks,
          fileMetadata,
          isReceiving,
          stopScanning,
          downloadFile,
        ]);

        const progress = fileMetadata.chunks
          ? Object.keys(decodedChunks).length
          : 0;
        const totalChunks = fileMetadata.chunks || 0;

        return (
          <div className="w-full max-w-2xl mx-auto p-4">
            <div className="flex flex-col items-center justify-center w-full">
              <div className="text-xl my-4 font-bold">Data Receiver Mode</div>
              <div className="text-sm mb-4 h-5">{userMessage}</div>
              <div className="text-sm mb-4">
                Progress: {progress} / {totalChunks}
              </div>

              {/* ì¹´ë©”ë¼ ì—ëŸ¬ í‘œì‹œ */}
              {cameraError && (
                <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
                  {cameraError}
                </div>
              )}

              {/* ìˆ˜ì‹  ë²„íŠ¼ */}
              {!isReceiving ? (
                <button
                  onClick={startReceiver}
                  className="mb-6 px-4 py-2 border-2 border-gray-500 rounded-md hover:bg-gray-100"
                >
                  Start Receiver
                </button>
              ) : (
                <button
                  onClick={stopReceiver}
                  className="mb-6 px-4 py-2 border-2 border-red-500 text-red-500 rounded-md hover:bg-red-50"
                >
                  Stop Receiver
                </button>
              )}

              {/* ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ */}
              <video
                ref={videoRef}
                muted
                autoPlay
                playsInline
                className="w-full border bg-gray-200 rounded-lg"
              />

              {/* ìˆ¨ê²¨ì§„ ìº”ë²„ìŠ¤ */}
              <canvas ref={canvasRef} style={{ display: "none" }} />

              {/* ê²°ê³¼ í‘œì‹œ */}
              {showResult && (
                <div className="w-full mt-6">
                  <div className="flex flex-col gap-2 mb-4">
                    <h3 className="text-lg font-semibold">
                      Received Text ({fileMetadata.name})
                    </h3>
                    <div className="flex gap-2 flex-wrap">
                      <button
                        onClick={copyText}
                        className="px-3 py-2 border-2 border-blue-500 text-blue-500 rounded-md hover:bg-blue-50 flex items-center gap-1"
                      >
                        ğŸ“‹ Copy
                      </button>
                      <button
                        onClick={shareText}
                        className="px-3 py-2 border-2 border-green-500 text-green-500 rounded-md hover:bg-green-50 flex items-center gap-1"
                      >
                        ğŸ“¤ í…ìŠ¤íŠ¸ ê³µìœ 
                      </button>
                      <button
                        onClick={shareAsFile}
                        className="px-3 py-2 border-2 border-orange-500 text-orange-500 rounded-md hover:bg-orange-50 flex items-center gap-1"
                      >
                        ğŸ“ íŒŒì¼ ê³µìœ 
                      </button>
                      <button
                        onClick={downloadAsFile}
                        className="px-3 py-2 border-2 border-purple-500 text-purple-500 rounded-md hover:bg-purple-50 flex items-center gap-1"
                      >
                        ğŸ’¾ Download
                      </button>
                    </div>
                  </div>
                  <textarea
                    readOnly
                    value={receivedText}
                    className="w-full h-72 p-2 border border-gray-300 rounded-md bg-gray-50 font-mono text-sm"
                  />
                </div>
              )}
            </div>
          </div>
        );
      };

      // ì•± ë Œë”ë§
      ReactDOM.render(<QRDataReceiver />, document.getElementById("root"));
    </script>
  </body>
</html>
